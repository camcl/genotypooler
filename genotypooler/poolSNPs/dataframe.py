import os, sys
import pysam
import pandas as pd
import numpy as np
from scipy.stats import *

rootdir = os.path.dirname(os.path.dirname(os.getcwd()))
sys.path.insert(0, rootdir)

from genotypooler.poolSNPs import chunkvcf as chkvcf
from genotypooler.poolSNPs import pybcf
from genotypooler.persotools.files import *

"""
Building pandas Dataframes from VCF-files for plotting
"""


class PandasMixedVCF(object):
    """
    Pandas objects and methods for manipulating VCF files. Any format.
    Implements pysam methods into Pandas structures.
    Drawback: extremely slow...
    """
    def __init__(self, vcfpath: FilePath, format: str = None, indextype: str = 'id'):
        """
        :param vcfpath:
        :param indextype: identifier for variants: 'id', 'chrom:pos'.
        Must be 'chrom:pos' if the input has been generated by Phaser
        """
        self.path = vcfpath
        self.fmt = format
        self.idx = indextype
        obj = pysam.VariantFile(self.path)
        self.samples = list(obj.header.samples)

    def load(self):
        # object returned can be read only once
        return pysam.VariantFile(self.path)

    @property
    def variants(self) -> pd.Index:
        """
        Read variants identifiers ordered as in the input file
        :return:
        """
        vcfobj = self.load()
        vars = []
        if self.idx == 'id':
            for var in vcfobj:
                vars.append(var.id)
        if self.idx == 'chrom:pos':
            for var in vcfobj:
                vars.append(':'.join([str(var.chrom), str(var.pos)]))

        return pd.Index(data=vars, dtype=str, name='variants')

    @property
    def pos(self) -> pd.DataFrame:
        """
        Read variants identifiers ordered as in the input file
        :return:
        """
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars),), dtype=float)
        for i, var in enumerate(vcfobj):
            arr[i] = var.pos

        return pd.DataFrame(arr, index=vars, columns=['positions'], dtype=float)

    @property
    def af_info(self) -> pd.DataFrame:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars), ), dtype=float)
        for i, var in enumerate(vcfobj):
            arr[i] = var.info['AF'][0]

        return pd.DataFrame(arr, index=vars, columns=['af_info'], dtype=float)

    @property
    def phases(self) -> pd.DataFrame:
        # TODO: if fmt GT
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars), len(self.samples)), dtype=float)
        for i, var in enumerate(vcfobj):
            pass
            # arr[i, :] = var.gt_phases

        return pd.DataFrame(arr, index=vars, columns=self.samples, dtype=bool)

    @property
    def alleles(self) -> pd.DataFrame:
        """
        Read ref-alt alleles for each variant
        :return: tuple, reference and alternate allele
        """
        vcfobj = self.load()
        vars = self.variants
        vars_alls = []
        for i, var in enumerate(vcfobj):
            vars_alls.append(var.alleles)

        return pd.DataFrame(vars_alls, index=vars, columns=['ref', 'alt'], dtype=str)

    def vcf2dframe(self) -> tuple:
        # TODO: deprecate
        """
       Throws the genotypes values of a VCF file into side-DataFrames.
       :return: two data frames, one for each allele of the genotype
       """
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples), 2), dtype=int)
        for i, var in enumerate(vcfobj):
            arr[i, :, :] = np.array(g[self.fmt] for g in var.samples.values()).astype(float)
        # alleles 1
        df0 = pd.DataFrame(arr[:, :, 0], index=vars.rename('id'), columns=self.samples)
        # alleles 2
        df1 = pd.DataFrame(arr[:, :, 1], index=vars.rename('id'), columns=self.samples)

        return df0, df1

    def genotypes(self) -> pd.DataFrame:
        """
       Throws the formatted genotypes values of a VCF file into a DataFrame.
       :return: DataFrame
       """
        lines = chkvcf.PysamVariantCallGenerator(self.path, format=self.fmt)
        df = pd.DataFrame(lines, index=self.variants.rename('id'), columns=self.samples)

        return df

    def trinary_encoding(self) -> pd.DataFrame:
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples)), dtype=float)
        if self.fmt.upper() == 'GT':
            missing = np.vectorize(lambda x: np.nan if x is None else x)
            for i, var in enumerate(vcfobj):
                # missing are read as None
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                tri = missing(gts).sum(axis=-1)
                arr[i, :] = np.nan_to_num(tri, nan=-1)
        elif self.fmt.upper() == 'GL':
            gtnan = np.array([np.nan, np.nan, np.nan])
            gt0 = np.array([0., 0., 0.])
            gt1 = np.array([0., 1., 0.])
            gt2 = np.array([0., 0., 2.])
            for i, var in enumerate(vcfobj):
                # convert GL to trinary (assume log-GL format according to VCF4.1 specifications)
                missing = lambda x: gtnan if 0.0 not in x else (gt0 if x[0] == 0.0 else (gt1 if x[1] == 0.0 else gt2))
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                tri = np.apply_along_axis(missing, -1, gts).sum(axis=-1)
                arr[i, :] = np.nan_to_num(tri, nan=-1)
        elif self.fmt.upper() == 'GP':
            gtnan = np.array([np.nan, np.nan, np.nan])
            gt0 = np.array([0., 0., 0.])
            gt1 = np.array([0., 1., 0.])
            gt2 = np.array([0., 0., 2.])
            for i, var in enumerate(vcfobj):
                # convert GP to ternary (assume GP format)
                missing = lambda x: gtnan if 1.0 not in x else (gt0 if x[0] == 1.0 else (gt1 if x[1] == 1.0 else gt2))
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                tri = np.apply_along_axis(missing, -1, gts).sum(axis=-1)
                arr[i, :] = np.nan_to_num(tri, nan=-1)
        dftrinary = pd.DataFrame(arr, index=vars, columns=self.samples, dtype=int)

        return dftrinary

    def gl_to_hexa_gt(self, x: np.ndarray) -> np.ndarray:
        """
        Convert GL (log GP) values to numerical unphased GT:
        * GT=0/. -> -0.5
        * GT=0/0 -> 0.0
        * GT=1/. -> 0.5
        * GT=0/1 -> 1.0
        * GT=1/1 -> 2.0
        :param x: GL values, nd.array([float, float, float])
        :return: GT, float
        """
        gtnan = np.array([np.nan, np.nan, np.nan])
        gt0 = np.array([0., 0., 0.])
        gt1 = np.array([0., 1., 0.])
        gt2 = np.array([0., 0., 2.])
        if np.equal(x, [-0.30103, -0.30103, -12]).all():
            return np.array([-0.25, -0.25, 0.])
        elif np.equal(x, [-12, -0.30103, -0.30103]).all():
            return np.array([0.0, 0.25, 0.25])
        elif x[0] == 0.0:
            return gt0
        elif x[1] == 0.0:
            return gt1
        elif x[2] == 0.0:
            return gt2
        else:
            return gtnan

    def hexa_encoding(self) -> pd.DataFrame:
        """
        Encode the GT genotypes as follows:
            * 0, 0 -> 0.0
            * 0, 1 -> 1.0
            * 1, 1 -> 2.0
            * None, None -> -1.0
            * 1, None -> 0.5
            * 0, None -> -0.5
        """
        # TODO: fmt GT only!
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples)), dtype=float)
        if self.fmt.upper() == 'GT':
            for i, var in enumerate(vcfobj):
                # missing are read as None
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                arr[i, :] = np.nan_to_num(gts, nan=-0.5).sum(axis=-1)
        elif self.fmt.upper() == 'GL':
            for i, var in enumerate(vcfobj):
                # convert GL to trinary (assume log-GL format according to VCF4.1 specifications)
                missing = lambda x: self.gl_to_hexa_gt(x)
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                tri = np.apply_along_axis(missing, -1, gts).sum(axis=-1)
                arr[i, :] = np.nan_to_num(tri, nan=-1)
        elif self.fmt.upper() == 'GP':
            log10func = lambda x: np.log10(x) if x > 1e-12 else -12.0
            for i, var in enumerate(vcfobj):
                # convert GL to trinary (assume log-GL format according to VCF4.1 specifications)
                missing = lambda x: self.gl_to_hexa_gt(log10func(x))
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                tri = np.apply_along_axis(missing, -1, gts).sum(axis=-1)
                arr[i, :] = np.nan_to_num(tri, nan=-1)
        dfhexa = pd.DataFrame(arr, index=vars, columns=self.samples, dtype=float)

        return dfhexa

    @property
    def missing_rate(self):
        trico = self.trinary_encoding()
        trico[trico == -1] = np.nan
        func = lambda x: np.sum(np.isnan(x)) / len(x)
        miss = trico.apply(func, axis=1, raw=True)
        miss.rename('missing_rate', inplace=True)
        return miss.to_frame()

    @property
    def aaf(self):
        trico = self.trinary_encoding()
        trico[trico == -1] = np.nan
        # calculate alternate allele frequency from non-missing genotypes
        func = lambda x: np.nansum(x) / (2 * np.sum(~np.isnan(x)))
        aaf = trico.apply(func, axis=1, raw=True)
        aaf.rename('aaf', inplace=True)
        return aaf.to_frame()

    @property
    def het_rate(self):
        trico = self.trinary_encoding()
        trico[trico == -1] = np.nan
        func = lambda x: np.where(x == 1, 1, 0).sum() / np.sum(~np.isnan(x))
        het_ra = trico.apply(func, axis=1, raw=True)
        het_ra.rename('het_rate', inplace=True)
        return het_ra.to_frame()

    @property
    def hom_ref_rate(self):
        trico = self.trinary_encoding()
        trico[trico == -1] = np.nan
        func = lambda x: np.where(x == 0, 1, 0).sum() / np.sum(~np.isnan(x))
        hom_rr = trico.apply(func, axis=1, raw=True)
        hom_rr.rename('hom_ref_rate', inplace=True)
        return hom_rr.to_frame()

    @property
    def hom_alt_rate(self):
        trico = self.trinary_encoding()
        trico[trico == -1] = np.nan
        func = lambda x: np.where(x == 2, 1, 0).sum() / np.sum(~np.isnan(x))
        hom_aa = trico.apply(func, axis=1, raw=True)
        hom_aa.rename('hom_alt_rate', inplace=True)
        return hom_aa.to_frame()

    def concatcols(self, args):
        vars = self.variants.to_frame(name='variants')
        df = vars.join(args)
        df.drop('variants', axis=1, inplace=True)
        return df

    @staticmethod
    def aaf_to_maf(s: pd.Series, name: str = 'maf'):
        func = lambda x: x if x <= 0.5 else 1 - x
        mafs = s.apply(func).rename(name)
        return mafs

    @property
    def maf(self):
        dfaaf = self.aaf
        maf = self.aaf_to_maf(dfaaf['aaf'])
        return maf.to_frame()

    @property
    def maf_info(self):
        dfafinfo = self.af_info
        maf = self.aaf_to_maf(dfafinfo['af_info'], name='maf_info')
        return maf.to_frame()

    @property
    def minor_allele(self) -> pd.DataFrame: # returns 0 if the ref allele is the minor allele, else 1
        aaf_val = self.aaf.values.flatten()
        minor_val = [1 if x <= 0.5 else 1 for x in aaf_val]
        dfminor = pd.DataFrame(data=minor_val, index=self.variants, columns=['minor_allele'], dtype=int)

        return dfminor


class PandasMinorVCF(PandasMixedVCF):
    """
    Returns genotypes for minor allele carriers only (homozygotes for major are set to NaN).
    """

    # def __init__(self): inherited from parent class

    def trinary_encoding(self) -> pd.DataFrame:
        vcfobj = self.load()
        vars = self.variants
        af = self.af_info
        arr = np.empty((len(vars), len(self.samples)), dtype=float)
        if self.fmt.upper() == 'GT':
            missing = np.vectorize(lambda x: np.nan if x is None else x)
            for i, var in enumerate(vcfobj):
                # missing are read as None
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                tri = missing(gts).sum(axis=-1)
                if af.iloc[i][0] <= 0.5:
                    tri[tri == 0] = np.nan
                else:
                    tri[tri == 2] = np.nan
                arr[i, :] = np.nan_to_num(tri, nan=-1)

        elif self.fmt.upper() == 'GL':
            gtnan = np.array([np.nan, np.nan, np.nan])
            gt0 = np.array([0., 0., 0.])
            gt1 = np.array([0., 1., 0.])
            gt2 = np.array([0., 0., 2.])
            for i, var in enumerate(vcfobj):
                # convert GL to trinary (assume log-GL format according to VCF4.1 specifications)
                missing = lambda x: gtnan if 0.0 not in x else (gt0 if x[0] == 0.0 else (gt1 if x[1] == 0.0 else gt2))
                gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
                tri = np.apply_along_axis(missing, -1, gts).sum(axis=-1)
                if af.iloc[i][0] <= 0.5:
                    tri[tri == 0] = np.nan
                else:
                    tri[tri == 2] = np.nan
                arr[i, :] = np.nan_to_num(tri, nan=-1)
        dftrinary = pd.DataFrame(arr, index=vars, columns=self.samples, dtype=int)

        return dftrinary


class PandasToVCF(object):
    """
    Writes a new VariantFile from a dataframe with samples name and (phased) GT.
    # TODO: GP are converted to GL format at writing for compatibility with the imputation methods.
    # TODO: Add GL format to the header if necessary.
    """
    def __init__(self, vcf_in: str, vcf_out: str, df_to_write: pd.DataFrame,
                 format_to: str, phased: bool, wd: str = os.getcwd()):
        """
        The NonOverlapping Repeated Block pooling design applied is provided with the design matrix.
        Pooling from only GT genotype format to only GT or GP format implemented.
        """
        self.vcf_in = pysam.VariantFile(vcf_in)
        self.path_in = vcf_in
        self.path_out = vcf_out
        self.df = df_to_write
        self.fmt_to = format_to.upper()
        assert (self.fmt_to == 'GT'), 'Writing to other formats than phased GT not implemented'
        self.phased = phased
        assert (self.phased is True), 'Writing to other formats than phased GT not implemented'
        self.wd = wd
        self.header = None
        self.str_header = []
        self.data = None
        self.str_data = []
        self.n_variants = 0

    def _new_header(self):
        """VCF header (metadata) to write as formatted text lines"""
        # GP header record
        for hrec in list(self.vcf_in.header.records):
            if not str(hrec).startswith('##bcftools_viewCommand'):
                self.str_header.append(str(hrec))
        str_header_last = '#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t'
        str_header_last += '\t'.join(sample for sample in self.df.columns)
        str_header_last += '\n'
        self.str_header.append(str_header_last)

    def _new_data(self):
        """Genotype data to write as formatted text lines"""
        str_data = []
        for n, var in enumerate(self.vcf_in.fetch()):
            id_var, id_val = self.df.index[n], self.df.values[n]
            info_fields = ['='.join([str(k), str(np.asarray(v).flatten()[0])]) for k, v in var.info.items()]
            info = ';'.join([kv for kv in info_fields])
            str_var = '''{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}'''.format(var.chrom,
                                                                      var.pos,
                                                                      id_var,
                                                                      var.ref,
                                                                      var.alts[0],
                                                                      int(var.qual) if var.qual is not None else '.',
                                                                      var.filter.keys()[
                                                                          0] if var.filter.keys() != [] else '.',
                                                                      info,
                                                                      'GT')
            str_var = str_var + '\t' + '\t'.join([f'{geno[0]}|{geno[1]}' for geno in id_val]) + '\n'
            self.str_data.append(str_var)

    def write(self) -> None:
        """Writes genotype data from a pandas DataFrame into an output file"""
        # load text header and text data to write
        self._new_header()
        self._new_data()
        # write as text-like file
        with open(self.path_out, 'w') as vcf_out:
            print('\r\nWriting metadata in {}'.format(self.path_out).ljust(80, '.'))
            vcf_out.writelines(self.str_header)
            print('\r\nWriting data in {}'.format(self.path_out).ljust(80, '.'))
            vcf_out.writelines(list(self.str_data))

        print('Writing data in {}: Done'.format(self.path_out).rjust(80, '.'))
        # compress and index the VCF file
        pybcf.bgzip(self.path_out, self.path_out + '.gz', wd=self.wd)
        pybcf.index(self.path_out + '.gz', wd=self.wd)
        os.remove(self.path_out)
